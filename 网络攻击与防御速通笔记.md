# 第一章
## 安全服务包括哪五种
### 1. 认证服务 (Authentication Service)

认证服务是安全的第一道防线，用于**核实实体（人、进程或设备）的身份**。

- **核心目的：** 确保“你就是你所声称的那个人”。
    
- **应用场景：** 用户登录系统、服务器证书验证（HTTPS）。
    
- **实现手段：** 密码、生物识别（指纹/人脸）、数字签名、数字证书。
    

### 2. 访问控制服务 (Access Control Service)

在认证身份后，访问控制决定了该身份**拥有哪些权限**，防止对资源的非授权使用。

- **核心目的：** 限制合法用户只能操作其权限范围内的资源。
    
- **应用场景：** 员工只能查看所属部门的文件；普通用户不能进入管理员后台。
    
- **实现手段：** 访问控制列表 (ACL)、基于角色的访问控制 (RBAC)。
    

### 3. 机密性服务 (Confidentiality Service)

机密性服务保护信息不被泄露给非授权的个人或实体。

- **核心目的：** 即使数据被窃听或截获，攻击者也无法读懂内容。
    
- **应用场景：** 网银转账信息加密、VPN 隧道传输。
    
- **实现手段：** 对称加密（如 AES）、非对称加密（如 RSA）。
    

### 4. 完整性服务 (Integrity Service)

完整性服务确保信息在传输或存储过程中**未被未经授权地篡改、删除或插入**。

- **核心目的：** 确保接收到的数据与发送时完全一致。
    
- **应用场景：** 软件下载时的校验码、电子合同的内容防篡改。
    
- **实现手段：** 散列函数（Hash）、消息认证码 (MAC)、数字签名。
    

### 5. 不可否认性服务 (Non-repudiation Service)

也称为**抗抵赖服务**，它通过提供证据来解决通信双方可能发生的抵赖争议。

- **核心目的：** 防止发送方否认发送过信息，或接收方否认收到过信息。
    
- **应用场景：** 电子商务交易记录、法律文件的电子签名。
    
- **实现手段：** 数字签名、受信任的第三方公证（CA）。

## 黑客攻击流程
### 第一阶段：踩点 (Footprinting / Reconnaissance)

这是攻击的准备阶段，目的是尽可能多地搜集目标的信息，而**不与目标系统产生直接交互**（被动踩点）或仅进行极少量的交互（主动踩点）。

- **目标：** 获取域名、IP 地址段、网络拓扑、员工信息、地理位置、甚至所使用的技术栈（如 Web 服务器版本）。
    
- **常用手段：**
    
    - **WHOIS 查询：** 获取域名注册信息。
        
    - **OSINT (开源情报)：** 通过搜索引擎（Google Hacking）、社交媒体（LinkedIn）寻找内部员工邮箱或技术讨论。
        
    - **DNS 记录查询：** 寻找子域名和邮件服务器地址。
        

### 第二阶段：扫描 (Scanning)

在有了初步的 IP 地址和域名后，黑客会利用工具探测目标网络中存活的主机及其开放的“大门”。

- **目标：** 发现存活主机、开放端口、正在运行的服务。
    
- **关键技术：**
    
    - **主机发现：** 使用 Ping 或 ARP 请求确认哪些 IP 是在线的。
        
    - **端口扫描：** 探测目标主机开放了哪些端口（如 80, 443, 3306）。
        
- **常用工具：** `Nmap`, `Masscan`。
    

### 第三阶段：查点 (Enumeration)

查点是扫描的深入，黑客会与目标端口建立**主动连接**，以获取更具体、更具破坏性的细节。

- **目标：** 获取操作系统的具体版本、服务程序的详细版本（Banner 抓取）、用户帐户名、共享目录、路由表等。
    
- **常见操作：**
    
    - **SNMP 查点：** 获取网络设备的配置信息。
        
    - **SMB 查点：** 寻找 Windows 系统的共享资源和空连接漏洞。
        
    - **HTTP 指纹识别：** 确定后端使用的是 PHP、Java 还是 Python。
        

### 第四阶段：攻击实施 (Gaining Access / Exploitation)

这是真正的“入侵”时刻。黑客利用前三个阶段搜集的漏洞信息（如弱口令、未修复的系统补丁、代码逻辑漏洞）执行攻击。

- **目标：** 获取系统控制权（Shell）、窃取敏感数据或提权。
    
- **攻击手段：**
    
    - **漏洞利用：** 使用溢出代码或 SQL 注入。
        
    - **社会工程学：** 钓鱼邮件诱导用户运行恶意程序。
        
    - **暴力破解：** 针对弱口令进行穷举。
        
- **常用工具：** `Metasploit`, `Burp Suite`, `SQLmap`。
    

### 第五阶段：攻击善后 (Post-Exploitation & Covering Tracks)

成功进入系统后，黑客需要确保能够长期潜伏（维持访问），并消除自己留下的痕迹。

- **维持访问 (Maintaining Access)：**
    
    - 安装**后门 (Backdoor)** 或 **Rootkit**。
        
    - 创建新的管理员账户。
        
- **攻击善后/清理痕迹 (Covering Tracks)：**
    
    - **删除日志：** 清除系统日志（Event Logs）、Web 访问日志。
        
    - **伪装工具：** 改变上传文件的修改时间，使其看起来像系统自带文件。
        
    - **清理工具：** 卸载攻击时使用的扫描器和脚本。

## 渗透测试流程
### 1. 前期交互 (Pre-engagement Interactions)

这是渗透测试的“法律保障”阶段。测试团队与客户进行正式沟通，明确测试的边界。

- **核心任务：** 确定测试范围（哪些 IP 或域名可以测）、测试时间、沟通渠道以及**免责声明**。
    
- **产出：** 签署正式的服务合同（SOW）和授权书。
    

### 2. 情报收集 (Intelligence Gathering)

这对应于之前提到的“踩点”。通过各种手段搜集目标的信息。

- **技术手段：** 利用公开渠道搜集目标的企业信息、网络资产、员工邮箱等。
    
- **分类：** * **被动收集：** 不触碰目标系统（如利用搜索引擎）。
    
    - **主动收集：** 与目标直接交互（如端口扫描）。
        

### 3. 威胁建模 (Threat Modeling)

这是渗透测试中**最体现逻辑**的一步。测试者站在攻击者的角度，分析目标最可能受到攻击的薄弱点。

- **核心任务：** 分析目标的业务流程，确定哪些资产最值钱（如数据库），并设计最可能的攻击路径。
    
- **目的：** 确保后续的漏洞扫描和利用更具针对性。
    

### 4. 漏洞分析 (Vulnerability Analysis)

在这一阶段，测试者将情报收集到的信息与已知的漏洞库进行比对，寻找进入系统的“钥匙”。

- **核心任务：** 发现系统、应用程序或配置中的缺陷。
    
- **方法：** * **自动扫描：** 使用 Nessus 或 OpenVAS 等工具。
    
    - **手动分析：** 人工验证扫描结果，排除误报，寻找逻辑漏洞。
        

### 5. 漏洞利用 (Exploitation)

这是整个测试的核心，旨在通过已发现的漏洞获取系统的控制权。

- **核心原则：** 必须在**受控且安全**的前提下进行，尽量不影响业务的正常运行。
    
- **常见动作：** 执行溢出脚本、注入 SQL 指令、破解弱口令。
    

### 6. 后渗透攻击 (Post-Exploitation)

进入系统后，评估该漏洞对业务可能造成的**实际影响力**。

- **核心任务：** * **横向移动：** 从已控制的主机转向内网其他更有价值的主机。
    
    - **权限提升：** 从普通用户权限提升至管理员权限（Root/Admin）。
        
    - **敏感数据提取：** 证明数据确实可以被窃取。
        

### 7. 报告 (Reporting)

这是渗透测试**最有价值**的产出，决定了测试的成败。

- **核心内容：**
    
    - **执行摘要：** 给管理层看的，说明整体安全态势。
        
    - **技术细节：** 给开发/运维看的，包括漏洞描述、复现步骤、截图。
        
    - **修复建议：** 针对每个发现的漏洞提供具体的加固方案。

## 端口扫描技术
### 1. TCP 连接扫描 (TCP Connect Scan)

这是最基础的扫描方式，利用操作系统的 `connect()` 系统调用。

- **原理：** 与目标端口完成完整的 **TCP 三次握手**。
    
- **结果：** * 收到 `SYN/ACK`：端口开放。
    
    - 收到 `RST`：端口关闭。
        
- **优点：** 准确度高，不需要特殊权限（普通用户即可执行）。
    
- **缺点：** 极易被防火墙或 IDS（入侵检测系统）记录，因为完整的连接会留下日志。
    

### 2. TCP SYN 扫描 (半开放扫描)

这是最流行的扫描方式，也是 Nmap 的默认选项（`-sS`）。

- **原理：** 只进行三次握手的前两步。发送 `SYN`，如果收到 `SYN/ACK`，则立即发送 `RST` 断开连接，而不发送最后的 `ACK`。
    
- **结果：** * 收到 `SYN/ACK`：端口开放。
    
    - 收到 `RST`：端口关闭。
        
- **优点：** 速度快，相对隐蔽（因为连接未真正建立，应用层通常不会记录日志）。
    

---

### 3. 隐蔽扫描 (TCP FIN, Null, Xmas 扫描)

这类扫描利用了 RFC 793 的一个特性：发送一个不包含 `SYN`、`RST` 或 `ACK` 标志的数据包。

- **TCP FIN 扫描：** 只发送 `FIN` 标志位。
    
- **原理：** * **关闭的端口：** 根据 RFC，应该返回一个 `RST` 包。
    
    - **开放的端口：** 应该忽略该包（不响应）。
        
- **优点：** 能绕过一些简单的包过滤防火墙。
    
- **缺点：** 在 Windows 系统上无效（Windows 不论端口开闭都会返回 `RST`），主要针对类 Unix 系统。
    

### 4. TCP ACK 扫描

这种扫描不用于确定端口是否开放，而是用于**探测防火墙规则**。

- **原理：** 发送一个仅设置 `ACK` 位的数据包。
    
- **结果：** * 收到 `RST`：说明数据包通过了防火墙，端口未被过滤。
    
    - 无响应/收到 ICMP 错误：说明端口被防火墙拦截（Filtered）。
        

---

### 5. TCP 窗口扫描 (TCP Window Scan)

类似于 ACK 扫描，但它会检查返回的 `RST` 包中的 **TCP 窗口大小** 字段。

- **原理：** 在某些操作系统（如 AIX、FreeBSD）中，开放端口返回的 `RST` 包窗口大小为正数，关闭端口返回的为零。
    
- **局限性：** 极度依赖特定的系统实现，适用范围较窄。
    

### 6. TCP Maimon 扫描

由安全专家 Uriel Maimon 发现，类似于 FIN 扫描。

- **原理：** 发送 `FIN/ACK` 标志位。
    
- **预期：** 依据 RFC，无论端口开闭都应返回 `RST`。但在某些 BSD 系统中，如果端口开放，则不会响应。
    

---

### 7. UDP 扫描 (UDP Scan)

由于 UDP 是无连接协议，扫描难度比 TCP 大得多。

- **原理：** 向目标发送一个 UDP 包（通常不含有效载荷）。
    
- **结果判断：**
    
    - **无响应：** 可能是端口开放，也可能是被防火墙过滤。
        
    - **收到 ICMP 端口不可达错误：** 明确表示端口关闭。
        
    - **收到 UDP 响应：** 明确表示端口开放（极少见）。
        
- **缺点：** 速度极慢，且结果极其不可靠。
- ![](assets/网络攻击与防御速通笔记/file-20251218230039730.png)
- ![](assets/网络攻击与防御速通笔记/file-20251218230256600.png)

## 主动式协议栈指纹识别技术
```bash
nmap -O ip
```
### 1. FIN 探测 (FIN Probe)

向目标一个**开放**的端口发送一个 `FIN` 包。

- **识别原理：** 根据 RFC 793 标准，开放端口应丢弃该包不予响应。但 Windows、BSDI、Cisco、HP-UX 等系统会违反标准回复一个 `RST`。这可以快速将 Windows 与其它类 Unix 系统区分开。
    

### 2. 无效标志探测 (BOGUS Flag Probe)

在 `SYN` 包的 TCP 首部中设置未定义的“无效”标志位（如保留位）。

- **识别原理：** 有些操作系统（如老版本的 Linux）在回包时会原样保留这些无效标志，而大多数现代安全系统会将其清除。这有助于识别特定的内核版本。
    

### 3. 初始序列号 (ISN) 采样探测

建立多次 TCP 连接，记录目标返回的 `SYN/ACK` 包中的初始序列号（Initial Sequence Number）。

- **识别原理：** 不同的 OS 生成 ISN 的算法不同。
    
    - **传统 Unix：** 随时间线性增长。
        
    - **Windows/现代 Linux：** 采用复杂的伪随机算法。
        
    - **老旧设备：** 可能是固定步长增加。
        

### 4. DF 标志位探测 (Don't Fragment Bit)

检查目标回包中 IP 首部的“不分片”(DF) 位。

- **识别原理：** 某些系统为了提高性能，默认对所有发出的包设置 DF 位；而另一些系统则不设置。通过观察目标在不同探测响应中 DF 位的变化（有的回包带 DF，有的不带），可以锁定系统族。
    

### 5. TCP 初始数据窗口大小 (Window Size)

检查目标在 `SYN/ACK` 响应包中声明的 `Window Size` 字段。

- **识别原理：** 这是一个非常可靠的指标。很多系统在初始化连接时使用独特的固定值。例如：
    
    - **Windows：** 常使用 8192 或 65535。
        
    - **Linux：** 常根据 MSS（最大报文段大小）的倍数动态计算（如 5840）。
        

### 6. ACK 值探测 (The ACK Value)

向关闭的端口发送探测包，分析返回 `RST` 包中的 `Acknowledgment Number`。

- **识别原理：** 当你发送一个特定序号的数据包给关掉的端口时，有的系统回包中的 ACK 字段等于你发送的 `Sequence Number`，有的则等于 `Seq + 1`。
    

### 7. TCP 选项探测 (TCP Options / Selective Acknowledgment)

在发送的 `SYN` 包中加入多种 TCP 选项（如 MSS、Window Scale、SACK、时间戳）。

- **识别原理：** 目标回包中选项的**支持程度**以及它们的**排列顺序**极具特征。即使两个系统支持同样的选项，它们在回包里对选项排序的先后顺序（比如 MSS 是否排在第一位）往往是固定的。
    

### 8. ICMP 消息探测

向关闭的 UDP 端口发送数据，诱发目标返回“ICMP 端口不可达”消息。

- **识别原理：**
    
    - **引用长度：** 不同系统在 ICMP 错误报文中引用的原始数据长度不同。
        
    - **错误率限制：** 通过高频发送包，观察目标是否限制了 ICMP 错误的回包速率。
        

### 9. 服务类型 (TOS) 探测

检查 ICMP 响应包或 TCP 响应包中的 IP 服务类型（Type of Service）字段。

- **识别原理：** 大多数 OS 对 ICMP 回显请求（Ping）回包的 TOS 设为 `0`，但有些特定的设备（如部分路由器）会设置独特的值。
    

### 10. 数据包分片处理探测 (IP Fragmentation)

发送重叠（Overlapping）或乱序的 IP 分片包。

- **识别原理：** 这是识别系统内核重组逻辑的关键。当两个分片重叠且内容冲突时：
    
    - **Windows：** 可能倾向于覆盖旧数据（使用新到的分片）。
        
    - **Linux/Unix：** 可能保留旧数据（丢弃重叠的新分片）。 这种重组算法的差异是操作系统最底层的“基因”。

## 被动式协议栈指纹识别技术
```bash
ping -c ip
```
被动捕获对方发出的消息如TTL再做出判断，其辅助作用。

## 查点
### 1. 查点的定义

查点是指攻击者通过与目标系统进行**主动连接**，利用各种查询和探测手段，搜集系统内部的具体信息。

- **本质：** 深度探测。
    
- **目的：** 发现合法的用户名、组名、共享资源、服务版本、路由表、审计设置等信息。
    
- **结果：** 为下一阶段的“攻击实施（获取权限）”寻找最容易突破的具体入口。
    

### 2. 查点的主要任务

在查点阶段，黑客通常试图获取以下具体信息：

- **网络资源和共享：** 发现内网中开放的共享文件夹（如 SMB 共享）。
    
- **用户信息：** 搜集系统中的有效用户名、用户组、管理员账号。
    
- **服务细节：** 探测特定服务的版本号和配置（如邮件服务器的 banner 信息）。
    
- **路由信息：** 提取 SNMP 数据或路由协议中的网络拓扑。
    
- **应用软件：** 识别正在运行的数据库、Web 应用框架等。
    

### 服务指纹分析技术 
一项可以分析目标网络的自动化技术。
```bash
nmap -sV ip
```

### 旗标抓取技术
连接远程应用观察其输出。
```bash
telent url 端口
nc -v url 端口
```

## 扫描与查点的防御措施
1. 使用不常用的端口进行监听，若发生请求，则认为有扫描。
2. 蜜罐（Honeypot） 是一种主动防御技术，其核心思想是“示假隐真”。它通过构建一个故意存在漏洞的虚假系统，诱导攻击者对其进行攻击，从而实现监控、溯源和保护真实资产的目的。
3. 审查日志的蛛丝马迹
4. 加固操作系统，更新补丁，关掉不用的端口

### **MAC 洪泛攻击（MAC Flooding Attack）** 
是一种针对局域网**二层交换机**的经典攻击手段。其核心目标是让交换机失去“智能化”的数据转发功能，迫使其退化为“集线器（Hub）”，从而方便攻击者窃听网络流量。

---
### 1. 攻击原理

要理解 MAC 洪泛，首先要了解交换机的工作机制：

- **MAC 地址表（CAM 表）：** 交换机内部有一张表，记录了哪个 **MAC 地址** 对应哪个 **物理端口**。
    
- **空间有限：** 交换机的内存（CAM 存储区）是有限的，只能存储几千到上万个 MAC 地址条目。
    
- **攻击逻辑：** 攻击者利用工具（如 `macof`）在短时间内发送成千上万个带有**伪造源 MAC 地址**的以太网帧。交换机会忠实地将这些虚假信息填入 CAM 表，直到表被完全**填满（溢出）**。
    

### 2. 攻击后果：失效保护模式（Fail-Open）

当交换机的 MAC 地址表满载后，它将无法学习新的 MAC 地址。此时，对于新进入的合法数据包，交换机会因为在表中找不到目标端口，而采取**“泛洪（Flooding）”**策略：

1. **退化为集线器：** 交换机会将接收到的所有数据包转发到**除了来源端口以外的所有端口**上。
    
2. **流量嗅探：** 攻击者只需在自己的端口启动抓包工具（如 Wireshark），就能接收到原本属于其他主机的数据，从而窃取账号、密码等敏感信息。

## **NT Hash**
（也称为 NTLM Hash）是微软 Windows 操作系统用于存储用户密码的标准加密格式。它是现代 Windows 系统（从 Windows NT 3.1 到最新的 Windows 11）身份验证的核心。

与早期的 **LM Hash** 不同，NT Hash 具有更强的安全性（尽管在现代标准下已被认为不够安全）。

---

### 1. NT Hash 的计算过程

NT Hash 的生成算法非常直接，主要分为三个步骤：

1. **Unicode 编码：** 将用户的明文密码转换为 **UTF-16 Little Endian** 编码。
    
    - 例如，密码 `Password` 会被处理为 `P\0a\0s\0s\0w\0o\0r\0d\0`。
        
2. **MD4 摘要：** 对编码后的二进制数据进行 **MD4 散列算法** 计算。
    
3. **生成结果：** 得到的 16 字节（128 位）二进制结果即为 NT Hash，通常以 32 位十六进制字符串表示。
    

$$Password \xrightarrow{UTF-16LE} Binary \xrightarrow{MD4} NTHash$$

---

### 2. NT Hash 的核心特性

- **无盐值 (No Salt)：** 这是 NT Hash 最大的弱点。如果两个用户的密码相同，他们的 NT Hash 也会完全相同。这使得它容易受到**彩虹表（Rainbow Table）**攻击。
    
- **大小写敏感：** 与 LM Hash 不同，NT Hash 严格区分大小写。
    
- **长度不受限：** 虽然 NT Hash 结果永远是 16 字节，但它可以支持非常长的明文密码（最高可达 127 个字符）。
    
- **协议兼容性：** 它是 NTLM v1 和 NTLM v2 身份验证协议的基础。

## windows系统的登录与身份验证
### 交互式登录 (Interactive Logon)

交互式登录是指用户**通过物理控制台**（键盘、显示器）或远程桌面（RDP）直接与操作系统进行的登录。

#### 验证流程：

1. **输入凭据**：用户在登录界面输入用户名和密码。
    
2. **传递信息**：Winlogon 将信息传递给 LSASS。
    
3. **身份验证**：
    
    - **本地登录**：LSASS 使用 **MSV1_0** 协议，将用户输入的密码计算成 NT Hash，并与本地 **SAM** 数据库中的 Hash 进行对比。
        
    - **域登录**：LSASS 调用 **Kerberos** 或 **NTLM** 协议，向域控制器（DC）请求验证。
        
4. **创建令牌**：验证成功后，系统会为用户创建一个 **访问令牌 (Access Token)**，用于后续操作的权限校验。
    

---

### 3. 网络登录 (Network Logon)

网络登录是指用户**已经登录了一台计算机**，但尝试访问网络中另一台计算机的资源（如共享文件夹、打印机或 IIS 网站）时发生的验证。

#### 核心特点：

- **不再次输入密码**：系统通常尝试使用当前已有的凭据进行“单点登录”（SSO）。
    
- **挑战/响应机制**：主要使用 **NTLM** 或 **Kerberos** 协议。

### NLTM
### 第一阶段：协商 (Negotiation) —— 建立共识

这是客户端与服务器初步“打招呼”的阶段。

1. **请求认证 (Type 1 Message: Negotiate)：** 客户端尝试访问服务器资源（如共享文件夹）。它向服务器发送一个“协商包”，告知服务器自己支持的 NTLM 版本（如 NTLM v2）、加密套件以及自己所在的域名。
    

### 第二阶段：挑战 (Challenge) —— 核心验证

这是防止重放攻击的关键步骤，由服务器发起。

2. **挑战 (Type 2 Message: Challenge)：** 服务器收到请求后，生成一个 **16 字节的随机数**（称为 **Nonce** 或 Challenge），并发送回客户端。这个随机数每次登录都是唯一的。
    

### 第三阶段：响应与验证 (Response & Verification) —— 最终确权

这是证明“我知道密码”但又不发送密码的过程。

3. **响应 (Type 3 Message: Authenticate)：** 客户端收到挑战值后，使用自己的 **NT Hash**（用户密码的散列值）对这个随机数进行加密计算，生成一个结果（称为 **Response**），然后连同用户名一起发给服务器。
    
4. **验证请求 (Validation Request)：**
    
    - **如果是本地账户：** 服务器直接从自己的 SAM 数据库提取对应的 NT Hash，对第 2 步发出的随机数进行同样的加密计算。
        
    - **如果是域账户：** 服务器无法解密，会将“用户名”、“随机数”和“客户端发回的响应”打包发送给 **域控制器 (DC)**。
        
5. **验证响应 (Validation Response)：**
    
    - 如果是域环境，DC 会在数据库中查找该用户的 NT Hash，计算结果后与客户端的结果比对。如果一致，告知服务器验证通过。
        
6. **服务器响应 (Final Server Response)：** 服务器最终告知客户端：认证成功，允许访问资源；或认证失败，拒绝连接。
### NTLM 认证的缺点（安全漏洞）

尽管它很方便，但在现代网络安全环境下，NTLM 存在严重的缺陷：

#### 1. 易受“哈希传递”攻击 (Pass-the-Hash, PtH)

虽然 NTLM 不传明文，但它直接依赖 **NT Hash**。

- **风险：** 攻击者只要从一台机器的内存中窃取了用户的 NT Hash（无需解密成明文），就可以直接代入 NTLM 流程中的“响应”阶段，从而冒充该用户登录其他服务器。
    

#### 2. NTLM 中继攻击 (NTLM Relay)

这是 NTLM 最著名的弱点。

- **风险：** 攻击者可以拦截客户端的认证请求，并将其转发（Relay）给另一台目标服务器。如果客户端拥有目标服务器的权限，攻击者就能顺势在目标服务器上执行命令。
    
- **原因：** NTLM 协议缺乏对“目的服务器”身份的强验证。
    

#### 3. 缺乏“相互认证” (No Mutual Authentication)

- **风险：** 在 NTLM 流程中，只有服务器在验证客户端，客户端并不知道与之通信的服务器是否真的是合法的。
    
- **后果：** 攻击者可以架设一个伪造的服务器，诱导客户端发起 NTLM 认证，从而收集用户的 **Net-NTLM Hash** 用于离线破解。
    

#### 4. 离线破解风险

- **风险：** 攻击者截获“挑战”和“响应”数据包后，可以使用高性能 GPU 进行暴力破解。
    
- **原因：** NTLM 使用的 MD4 算法极快（每秒可尝试数十亿次），且协议本身**没有加盐（Salt）**机制。
    

#### 5. 对中间人攻击 (MITM) 抵抗力弱

如果网络中没有强制开启 **SMB 签名**，攻击者可以轻易篡改正在进行的 NTLM 会话，甚至降级其加密强度。

